# -*- coding: utf-8 -*-
"""encoding-1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HRCb1U_O4xqL8s3XBXoU95GLUqH9hMf5
"""

from os.path import exists
from wheel.pep425tags import get_abbr_impl, get_impl_ver, get_abi_tag
platform = '{}{}-{}'.format(get_abbr_impl(), get_impl_ver(), get_abi_tag())
cuda_output = !ldconfig -p|grep cudart.so|sed -e 's/.*\.\([0-9]*\)\.\([0-9]*\)$/cu\1\2/'
accelerator = cuda_output[0] if exists('/dev/nvidia0') else 'cpu'

!pip install -q http://download.pytorch.org/whl/{accelerator}/torch-0.4.1-{platform}-linux_x86_64.whl torchvision
!pip install deap
!pip install torchsummary

import random 
import numpy as np 
from deap import base, creator,tools,algorithms
from scipy.stats import bernoulli
import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision.transforms as transforms
from torchsummary import summary

transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])


trainsetMnist=torchvision.datasets.MNIST(root='./data', train=True,download=True, transform=transform)
trainloaderMnist = torch.utils.data.DataLoader(trainsetMnist, batch_size=4,
                                          shuffle=True, num_workers=2)

testsetMnist = torchvision.datasets.MNIST(root='./data', train=False,download=True, transform=transform)
testloaderMnist = torch.utils.data.DataLoader(testsetMnist, batch_size=4,
                                         shuffle=False, num_workers=2)
classes = ('0', '1', '2', '3',
           '4', '5', '6', '7', '8', '9')

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

class Net(nn.Module):
    def __init__(self,chromosome):
        super(Net, self).__init__()
        self.chromosome=chromosome
        self.conv1 = nn.Conv2d(1, 20, 3, 1)
     
        print(chromosome)
        print(chromosome.count(1))
        countConvLayers=chromosome.count(1)
        
        
       
        inputSize=20
        outputSize=40
        self.totalConvs=[]
        if(countConvLayers==1):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          
         
          
        
        elif(countConvLayers==2):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          
         
          inputSize=outputSize
          outputSize+=20
          self.conv3=nn.Conv2d(inputSize, outputSize, 3, 1)
          
          
        
        elif(countConvLayers==3):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv3=nn.Conv2d(inputSize, outputSize, 3, 1)
         
          
          inputSize=outputSize
          outputSize+=20
          self.conv4=nn.Conv2d(inputSize, outputSize, 3, 1)
          
          
          
          
        elif(countConvLayers==4):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv3=nn.Conv2d(inputSize, outputSize, 3, 1)
        
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv4=nn.Conv2d(inputSize, outputSize, 3, 1)
          
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv5=nn.Conv2d(inputSize, outputSize, 3, 1)
         
        
        self.filterSize=20
        self.imageSize=26
        for gene in self.chromosome:
          if(gene==0):
            self.imageSize=self.imageSize/2
          
          else:
            self.filterSize+=20
            self.imageSize=self.imageSize-2
        
        self.filterSize=int(self.filterSize)
        self.imageSize=int(self.imageSize)
        
        print(self.filterSize)
        print(self.imageSize)
        
        self.fc1 = nn.Linear(self.filterSize*self.imageSize*self.imageSize, 500)
        self.fc2 = nn.Linear(500, 10)

    def forward(self, x):
#         print(x.size())
        x = F.relu(self.conv1(x))
#         print(x.size())
        
        count=1
        for gene in self.chromosome:
          if(gene==0):
            x=F.max_pool2d(x, 2, 2)
            
          if(gene==1):
            
            if(count==1):
              x=F.relu(self.conv2(x))
              count+=1
            elif(count==2):
              x=F.relu(self.conv3(x))
              count+=1
            
            elif(count==3):
              x=F.relu(self.conv4(x))
              count+=1
                
            elif(count==4):
              x=F.relu(self.conv5(x))
              count+=1
            
#         print(x.size())
        

        
        x = x.view(-1,self.filterSize*self.imageSize*self.imageSize)
#         print(x.size())

        
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

def trainFunction(net,trainData,chromosome,optimizer,criterion):
    for epoch in range(totalEpochs):
        currentLoss=0.0
        for i,data in enumerate(trainData,0):

            inputs,labels=data
            inputs, labels = inputs.to(device), labels.to(device)
            
            optimizer.zero_grad()
            
            outputs=net(inputs)
            loss=criterion(outputs,labels)
            loss.backward()
            optimizer.step()
            currentLoss +=loss.item()
            if(i%2000)==1999:
                print("[%d,%5d] loss: %.3f" %(epoch+1,i+1,currentLoss/2000))
                currentLoss=0.0
                
    print("Finished Training")
    return net

def testFunction(net,testLoader):
    correct=0
    total=0
    with torch.no_grad():
        for data in testLoader:
            images,labels=data
            images, labels = images.to(device), labels.to(device)
            
            outputs=net(images)
            _,predicted=torch.max(outputs.data,1)
            total+=labels.size(0)
            correct+=(predicted==labels).sum().item()
    accuracy=correct/total
    print("Accuracy: "+str(accuracy))
    return np.float32(accuracy)

def scoreFunction(chromosome):
  print(chromosome)
  net = Net(chromosome)
  
  net.to(device)
  print(net)
  criterion = nn.CrossEntropyLoss()
  optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
  net=trainFunction(net,trainloaderMnist,chromosome,optimizer,criterion)
  return testFunction(net,testloaderMnist),

totalEpochs=2
chromosomeSize=4

population_size = 4
num_generations = 2

creator.create("FitnessMax", base.Fitness, weights = (1.0,))
creator.create("Individual", list , fitness = creator.FitnessMax)

toolbox = base.Toolbox()
toolbox.register("binary", bernoulli.rvs, 0.5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.binary, n = chromosomeSize)
toolbox.register("population", tools.initRepeat, list , toolbox.individual)

toolbox.register("mate", tools.cxOrdered)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb = 0.5)
toolbox.register("select", tools.selRoulette)
toolbox.register("evaluate", scoreFunction)

popl = toolbox.population(n = population_size)
result = algorithms.eaSimple(popl, toolbox, cxpb = 0.4, mutpb = 0.05, ngen = num_generations, verbose = True)

# print top-3 optimal solutions 
best_individuals = tools.selBest(popl, k = 3)
for bi in best_individuals:
    print(bi)

trainsetCifar = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)
trainloaderCifar = torch.utils.data.DataLoader(trainset, batch_size=4,
                                          shuffle=True, num_workers=2)

testsetCifar = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
testloaderCifar = torch.utils.data.DataLoader(testset, batch_size=4,
                                         shuffle=False, num_workers=2)

classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')

bestChromosome=[1,1,1,0]

print(bestChromosome)
net = Net(bestChromosome)
net.to(device)
print(net)
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
net=trainFunction(net,trainloaderCifar,bestChromosome,optimizer,criterion)
testFunction(net,testloaderCifar)



summary(net,(1,28,28))

print(bestChromosome)
net = Net(bestChromosome)
net.to(device)
print(net)
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
net=trainFunction(net,trainloaderMnist,bestChromosome,optimizer,criterion)
testFunction(net,testloaderMnist)