# -*- coding: utf-8 -*-
"""encoding-2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16KjzH8OruBgPvKS5pullpd3xMkRdDC36
"""

from os.path import exists
from wheel.pep425tags import get_abbr_impl, get_impl_ver, get_abi_tag
platform = '{}{}-{}'.format(get_abbr_impl(), get_impl_ver(), get_abi_tag())
cuda_output = !ldconfig -p|grep cudart.so|sed -e 's/.*\.\([0-9]*\)\.\([0-9]*\)$/cu\1\2/'
accelerator = cuda_output[0] if exists('/dev/nvidia0') else 'cpu'

!pip install -q http://download.pytorch.org/whl/{accelerator}/torch-0.4.1-{platform}-linux_x86_64.whl torchvision
!pip install deap
!pip install torchsummary

import random 
import numpy as np 
from deap import base, creator,tools,algorithms
from scipy.stats import bernoulli
import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision.transforms as transforms
from torchsummary import summary

transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])


trainsetMnist=torchvision.datasets.MNIST(root='./data', train=True,download=True, transform=transform)
trainloaderMnist = torch.utils.data.DataLoader(trainsetMnist, batch_size=4,
                                          shuffle=True, num_workers=2)

testsetMnist = torchvision.datasets.MNIST(root='./data', train=False,download=True, transform=transform)
testloaderMnist = torch.utils.data.DataLoader(testsetMnist, batch_size=4,
                                         shuffle=False, num_workers=2)
classes = ('0', '1', '2', '3',
           '4', '5', '6', '7', '8', '9')

device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

def countConvLayers(chromosome):
  count =0
  temp=0
  for i in chromosome:
    
    if(temp%2==0 and i==1):
      count+=1
    temp+=1
  return count



def countPoolLayers(chromosome):
  count =0
  temp=0
  for i in chromosome:
    
    if(temp%2==0 and i==0):
      count+=1
    temp+=1
  return count

class Net(nn.Module):
    def __init__(self,chromosome):
        super(Net, self).__init__()
        self.chromosome=chromosome
        self.conv1 = nn.Conv2d(1, 20, 3, 1)
     
        print("chromosome: ",chromosome)
        
        totalConvLayers=countConvLayers(chromosome)
        print("TOTAL CONV LAYER: ",totalConvLayers)
        
        
        
       
        inputSize=20
        outputSize=40

        
        if(totalConvLayers==1):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride2=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
         
          
        
        elif(totalConvLayers==2):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride2=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
         
          inputSize=outputSize
          outputSize+=20
          self.conv3=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride3=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
        
        elif(totalConvLayers==3):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride2=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv3=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride3=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
         
          
          inputSize=outputSize
          outputSize+=20
          self.conv4=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride4=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
          
          
        elif(totalConvLayers==4):
          self.conv2=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride2=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv3=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride3=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv4=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride4=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
          
          
          
          inputSize=outputSize
          outputSize+=20
          self.conv5=nn.Conv2d(inputSize, outputSize, 3, 1)
          self.convStride5=nn.Conv2d(inputSize, outputSize, 3, 2,3)
          
         
        
        self.filterSize=20
        self.imageSize=26
        
        index=0
        for gene in self.chromosome:
          
          if(index%2==0):
            
            print("filter size: ",self.filterSize)
            print("image size: ",self.imageSize)
        
            if(gene==0):
              self.imageSize=self.imageSize/2
          
            else:
              if(chromosome[index+1]==0):
                self.filterSize+=20
                self.imageSize=self.imageSize-2
              else:
                self.filterSize+=20
                self.imageSize=np.floor((self.imageSize+3)/2)+1
                
                
          index+=1
        self.filterSize=int(self.filterSize)
        self.imageSize=int(self.imageSize)
        
        print("filter size: ",self.filterSize)
        print("image size: ",self.imageSize)
        
        self.fc1 = nn.Linear(self.filterSize*self.imageSize*self.imageSize, 500)
        self.fc2 = nn.Linear(500, 10)

    def forward(self, x):
#         print(x.size())
        x = F.relu(self.conv1(x))
#         print(x.size())
        
        count=1
        index=0
        for gene in self.chromosome:
          
          if(index%2==0):
#             print("SIZE: ",x.size())
            if(gene==0):
              x=F.max_pool2d(x, 2, 2)
            
            if(gene==1):
            
              if(count==1 and self.chromosome[index+1]==0 ):
                x=F.relu(self.conv2(x))
              
              elif(count==1 and self.chromosome[index+1]==1 ):
                x=F.relu(self.convStride2(x))
              
              
              elif(count==2 and self.chromosome[index+1]==0 ):
                x=F.relu(self.conv3(x))
              
              elif(count==2 and self.chromosome[index+1]==1 ):
                x=F.relu(self.convStride3(x))
              
              
              elif(count==3 and self.chromosome[index+1]==0 ):
                x=F.relu(self.conv4(x))
              
              elif(count==3 and self.chromosome[index+1]==1 ):
                x=F.relu(self.convStride4(x))
              
              
              elif(count==4 and self.chromosome[index+1]==0 ):
                x=F.relu(self.conv5(x))
              
              elif(count==4 and self.chromosome[index+1]==1 ):
                x=F.relu(self.convStride5(x)) 
              count+=1
          index+=1

        

        
        x = x.view(-1,self.filterSize*self.imageSize*self.imageSize)
#         print(x.size())

        
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

def trainFunction(net,trainData,chromosome,optimizer,criterion):
    totalEpochs=2
    for epoch in range(totalEpochs):
        currentLoss=0.0
        for i,data in enumerate(trainData,0):

            inputs,labels=data
            inputs, labels = inputs.to(device), labels.to(device)
            
            optimizer.zero_grad()
            
            outputs=net(inputs)
            loss=criterion(outputs,labels)
            loss.backward()
            optimizer.step()
            currentLoss +=loss.item()
            if(i%2000)==1999:
                print("[%d,%5d] loss: %.3f" %(epoch+1,i+1,currentLoss/2000))
                currentLoss=0.0
                
    print("Finished Training")
    return net

  
def testFunction(net,testLoader):
    correct=0
    total=0
    with torch.no_grad():
        for data in testLoader:
            images,labels=data
            images, labels = images.to(device), labels.to(device)
            
            outputs=net(images)
            _,predicted=torch.max(outputs.data,1)
            total+=labels.size(0)
            correct+=(predicted==labels).sum().item()
    accuracy=correct/total
    print("Accuracy: "+str(accuracy))
    return np.float32(accuracy)

def scoreFunction(chromosome):
  print(chromosome)
  net = Net(chromosome)
  
  net.to(device)
  print(net)
  criterion = nn.CrossEntropyLoss()
  optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
  net=trainFunction(net,trainloaderMnist,chromosome,optimizer,criterion)
  return testFunction(net,testloaderMnist),



totalEpochs=2
chromosomeSize=8

population_size = 4
num_generations = 2

creator.create("FitnessMax", base.Fitness, weights = (1.0,))
creator.create("Individual", list , fitness = creator.FitnessMax)

toolbox = base.Toolbox()
toolbox.register("binary", bernoulli.rvs, 0.5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.binary, n = chromosomeSize)
toolbox.register("population", tools.initRepeat, list , toolbox.individual)

toolbox.register("mate", tools.cxOrdered)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb = 0.5)
toolbox.register("select", tools.selRoulette)
toolbox.register("evaluate", scoreFunction)

popl = toolbox.population(n = population_size)
result = algorithms.eaSimple(popl, toolbox, cxpb = 0.4, mutpb = 0.05, ngen = num_generations, verbose = True)

# print top-3 optimal solutions 
best_individuals = tools.selBest(popl, k = 3)
for bi in best_individuals:
    print(bi)

bestChromosome=[1, 0, 1, 1, 1, 0, 0, 1]
scoreFunction(bestChromosome)

summary(net,(3,28,28))

trainsetCifar = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)
trainloaderCifar = torch.utils.data.DataLoader(trainsetCifar, batch_size=4,
                                          shuffle=True, num_workers=2)

testsetCifar = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
testloaderCifar = torch.utils.data.DataLoader(testsetCifar, batch_size=4,
                                         shuffle=False, num_workers=2)

classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')

bestChromosome=[1, 0, 1, 1, 1, 0, 0, 1]

print(bestChromosome)
net = Net(bestChromosome)
net.to(device)
print(net)
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
net=trainFunction(net,trainloaderCifar,bestChromosome,optimizer,criterion)
testFunction(net,testloaderCifar)

#Author's code-https://github.com/aqibsaeed/Genetic-CNN/blob/master/Genetic%20CNN.ipynb
# Pytorch Code- https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py
# https://deap.readthedocs.io/en/master/